<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>POSTURA</title>
<style>
  /* Page + Header */
  :root{
    --soft-yellow-1:#FFFDE7;
    --soft-yellow-2:#FFF9C4;
    --accent:#f9a825;
    --muted:#4a4a4a;
    --card-bg: #ffffff;
  }
  html,body{height:100%; margin:0;}
  body{
    font-family: 'Segoe UI', Poppins, system-ui, Arial, sans-serif;
    background: linear-gradient(160deg, var(--soft-yellow-1), var(--soft-yellow-2));
    color:var(--muted);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }
  header{
    position: sticky;
    top:0;
    display:flex;
    gap:16px;
    align-items:center;
    padding:12px 18px;
    background: rgba(255,255,240,0.85);
    backdrop-filter: blur(6px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    z-index:100;
  }
  header img.logo{
    width:56px;
    height:56px;
    border-radius:10px;
    object-fit:cover;
    box-shadow:0 4px 12px rgba(0,0,0,0.12);
  }
  header h1{ margin:0; font-size:1.25rem; color:#5c4b00; }

  /* Container */
  .wrap{
    max-width:880px;
    margin:20px auto;
    padding:18px;
  }
  .container{
    background:var(--card-bg);
    border-radius:14px;
    padding:22px;
    box-shadow:0 12px 30px rgba(0,0,0,0.06);
    text-align:center;
  }

  h2{ color:var(--accent); margin:6px 0 12px; }
  p { margin:6px 0 12px; color:#555; }

  /* Controls */
  .controls{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:center; margin-bottom:12px; }
  input[type=file]{ display:inline-block; padding:8px; border-radius:8px; background:#fff7d6; border:1px solid #f0e0a0; cursor:pointer; }
  button{
    background: linear-gradient(135deg,#fbc02d,#f9a825);
    color:white;
    border:0;
    padding:10px 14px;
    border-radius:10px;
    cursor:pointer;
    font-weight:600;
    box-shadow: 0 6px 14px rgba(0,0,0,0.08);
    transition: transform .12s ease, box-shadow .12s ease;
  }
  button:hover{ transform: translateY(-2px); box-shadow: 0 10px 22px rgba(0,0,0,0.10); }
  button.secondary{ background:#fff3e0; color:#4a4a4a; border:1px solid #f2d38a; }

  /* Canvas / Video */
  canvas{ width:100%; max-height:560px; border-radius:12px; border:2px dashed rgba(251, 192, 45, 0.25); display:block; margin:12px auto; }
  video{ width:100%; max-height:480px; border-radius:12px; display:block; margin:12px auto; }

  /* Info boxes */
  #result{ margin-top:12px; font-size:18px; font-weight:700; color:#333; min-height:36px; }
  .processing{ color:#f57f17; font-weight:700; animation:pulse .9s infinite alternate; }
  @keyframes pulse { from{opacity:.6} to{opacity:1} }

  /* History */
  #historyBox{ margin-top:18px; text-align:left; max-height:240px; overflow:auto; padding-right:6px; }
  .historyCard{
    border-radius:10px; padding:10px 12px; margin-bottom:10px;
    box-shadow:0 6px 14px rgba(0,0,0,0.04); background:#fff;
  }

  /* Small screens */
  @media (max-width:600px){
    header{ padding:10px 12px; gap:10px; }
    .wrap{ padding:10px; }
    .container{ padding:14px; }
    header img.logo{ width:48px; height:48px; }
  }
</style>
</head>
<body>

<header>
  <!-- logo.png is in repository as requested; visible on every page -->
  <img src="logo.png" alt="POSTURA logo" class="logo">
  <h1>POSTURA</h1>
</header>

<div class="wrap">
  <!-- FRONT PAGE -->
  <div id="frontPage" class="container">
    <h2>POSTURA</h2>
    <p>Welcome to <strong>POSTURA</strong> — a tool to measure <strong>Cervical Vertebral Angle (CVA)</strong>.</p>

    <div style="text-align:left; max-width:760px; margin:0 auto;">
      <h3 style="color:var(--accent); margin-bottom:6px;">Instructions</h3>
      <ol>
        <li>Upload a side-view photo or use your camera.</li>
        <li>Click on the <strong>tragus (ear)</strong> first.</li>
        <li>Then click on <strong>C7 (neck base)</strong>.</li>
        <li>Save each attempt to record results (up to 3 attempts).</li>
      </ol>
      <img src="tragus.jpg" alt="Reference points" style="display:block; max-width:300px; margin:10px 0;">
    </div>

    <div style="margin-top:14px;">
      <button onclick="startApp()">Start</button>
    </div>
  </div>

  <!-- MAIN APP -->
  <div id="mainApp" class="container" style="display:none;">
    <h2>POSTURA</h2>

    <div class="controls" aria-hidden="false">
      <input id="upload" type="file" accept="image/*" aria-label="Upload photo">
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="openCameraBtn" type="button">Open Camera</button>
        <button id="flipCameraBtn" type="button" style="display:none;" class="secondary">Flip Camera</button>
        <button id="closeCameraBtn" type="button" style="display:none;" class="secondary">Close Camera</button>
        <button id="snapBtn" type="button" style="display:none;">Capture Photo</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="resetPointsBtn" class="secondary">Reset Points</button>
        <button id="saveAttemptBtn" class="secondary" style="display:none;">Save Attempt</button>
        <button id="resetImageBtn" class="secondary">Capture / Upload Again</button>
        <button id="clearHistoryBtn" class="secondary">Clear History</button>
      </div>
    </div>

    <video id="camera" autoplay playsinline style="display:none;"></video>
    <canvas id="canvas"></canvas>

    <div id="processing" class="processing" style="display:none;">Processing… Please wait</div>
    <div id="result">Upload or capture a photo to start</div>

    <div id="historyBox" aria-live="polite"></div>

    <div style="margin-top:10px;">
      <button onclick="goBack()" class="secondary">⬅ Back to Instructions</button>
    </div>
  </div>
</div>

<!-- Tensorflow / BodyPix -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.9.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0"></script>

<script>
/* ============================
   Variables (app state)
   ============================ */
const frontPage = document.getElementById('frontPage');
const mainApp = document.getElementById('mainApp');
const upload = document.getElementById('upload');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const result = document.getElementById('result');
const processingDiv = document.getElementById('processing');
const historyBox = document.getElementById('historyBox');

const openCameraBtn = document.getElementById('openCameraBtn');
const closeCameraBtn = document.getElementById('closeCameraBtn');
const flipCameraBtn = document.getElementById('flipCameraBtn');
const snapBtn = document.getElementById('snapBtn');
const resetPointsBtn = document.getElementById('resetPointsBtn');
const resetImageBtn = document.getElementById('resetImageBtn');
const saveAttemptBtn = document.getElementById('saveAttemptBtn');
const clearHistoryBtn = document.getElementById('clearHistoryBtn');

let img = new Image();
let net = null;
let segmentationMask = null;
let stream = null;
let currentAttempt = null; // holds two points
let savedAttempts = []; // up to 3 attempts (original behavior)
let attemptCount = 0;
const maxAttempts = 3;
const attemptColors = ["#f44336","#4caf50","#2196f3"]; // color per attempt
let useBackCamera = true;

/* ============================
   Page control
   ============================ */
function startApp(){
  frontPage.style.display='none';
  mainApp.style.display='block';
  loadHistory(); // restore previous history if any
}
function goBack(){
  mainApp.style.display='none';
  frontPage.style.display='block';
}

/* ============================
   Utilities
   ============================ */
function showProcessing(show){ processingDiv.style.display = show ? 'block' : 'none'; }
function drawCanvas(){ 
  if(!img || !img.src) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img,0,0,canvas.width,canvas.height);

  // re-draw saved attempts overlays
  savedAttempts.forEach((obj,i)=>{
    if(obj.points){
      ctx.strokeStyle = attemptColors[i % attemptColors.length];
      ctx.fillStyle = attemptColors[i % attemptColors.length];
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(obj.points[0].x, obj.points[0].y);
      ctx.lineTo(obj.points[1].x, obj.points[1].y);
      ctx.stroke();
      obj.points.forEach(p=>{
        ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
      });
    }
  });

  // draw current attempt markers/line if exists
  if(currentAttempt && currentAttempt.length > 0){
    ctx.fillStyle = 'orange';
    currentAttempt.forEach(p=>{
      ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
    });
    if(currentAttempt.length === 2){
      // posture (oblique) line
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(currentAttempt[0].x,currentAttempt[0].y); ctx.lineTo(currentAttempt[1].x,currentAttempt[1].y); ctx.stroke();
    }
  }
}

/* ============================
   Load BodyPix (optimized)
   ============================ */
bodyPix.load({ architecture:'MobileNetV1', outputStride:16, multiplier:0.75 })
.then(m => { net = m; console.log("✅ BodyPix loaded"); })
.catch(err => console.warn("BodyPix load error:", err));

/* ============================
   Image upload handling
   ============================ */
upload.addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  showProcessing(true);
  const reader = new FileReader();
  reader.onload = ev => {
    img.onload = async () => {
      // scale canvas to 0.6 for consistent UI (as in original)
      canvas.width = Math.round(img.width * 0.6);
      canvas.height = Math.round(img.height * 0.6);
      drawCanvas();
      resetAttemptData();
      if(net) await segmentPerson(img);
      showProcessing(false);
      result.innerHTML = "Click 2 points: (1) Tragus, (2) C7";
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

/* ============================
   Camera functions (mobile back default + flip)
   ============================ */
function isMobile(){ return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent); }

openCameraBtn.addEventListener('click', async ()=>{
  await startCamera();
});

async function startCamera(){
  try{
    const constraints = isMobile()
      ? { video: { facingMode: useBackCamera ? { exact: "environment" } : "user" } }
      : { video: true };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    const video = document.getElementById('camera');
    video.srcObject = stream;
    video.style.display = 'block';
    snapBtn.style.display = 'inline-block';
    closeCameraBtn.style.display = 'inline-block';
    openCameraBtn.style.display = 'none';

    // show flip control on mobile
    if(isMobile()){
      flipCameraBtn.style.display = 'inline-block';
      flipCameraBtn.onclick = async () => {
        useBackCamera = !useBackCamera;
        stopCamera();
        await startCamera();
      };
    } else {
      flipCameraBtn.style.display = 'none';
    }
  } catch(err){
    console.error(err);
    alert("Camera not available or permission denied.");
  }
}

snapBtn.addEventListener('click', async ()=>{
  const video = document.getElementById('camera');
  if(!video.videoWidth) return;
  canvas.width = Math.round(video.videoWidth * 0.6);
  canvas.height = Math.round(video.videoHeight * 0.6);
  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  img.src = canvas.toDataURL();
  resetAttemptData();
  showProcessing(true);
  if(net) await segmentPerson(img);
  showProcessing(false);
  stopCamera();
});

closeCameraBtn.addEventListener('click', stopCamera);

function stopCamera(){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
  const video = document.getElementById('camera');
  video.style.display = 'none';
  snapBtn.style.display = 'none';
  closeCameraBtn.style.display = 'none';
  openCameraBtn.style.display = 'inline-block';
  flipCameraBtn.style.display = 'none';
}

/* ============================
   BodyPix segmentation helper
   ============================ */
async function segmentPerson(imgElement){
  try{
    const segmentation = await net.segmentPerson(imgElement);
    segmentationMask = segmentation.data;
    const mask = bodyPix.toMask(segmentation, {r:255,g:255,b:0,a:100}, {r:0,g:0,b:0,a:0});
    bodyPix.drawMask(canvas, imgElement, mask, 0.3, 0, false);
    // re-draw currentAttempt markers if any over mask
    drawCanvas();
  }catch(err){
    console.warn("Segmentation failed:", err);
  }
}

/* ============================
   Click handling, baseline (to left), angle & validations
   ============================ */
let points = []; // internal for clicks (two points per attempt)

canvas.addEventListener('click', (e)=>{
  if(!canvas.width) return;
  const rect = canvas.getBoundingClientRect();
  const x = Math.round(e.clientX - rect.left);
  const y = Math.round(e.clientY - rect.top);

  // If segmentation exists, ensure click is on person
  if(segmentationMask && canvas.width > 0){
    const idx = Math.floor(y) * canvas.width + Math.floor(x);
    // segmentationMask length matches original image size; because we scaled canvas,
    // segmentationMask indexing may not exactly match scaled coordinates.
    // We'll skip strict mask check to avoid false negatives if sizes differ.
    // If segmentation data length equals canvas.width*canvas.height we can check safely:
    if(segmentationMask.length === canvas.width * canvas.height){
      if(segmentationMask[idx] === 0){
        result.innerHTML = "<span class='warning'>⚠️ Please click only on the person.</span>";
        return;
      }
    }
  }

  // Draw marker
  ctx.fillStyle = 'red';
  ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();

  points.push({x,y});

  // If two clicks -> compute and show angle; allow up to 3 saved attempts (same as original)
  if(points.length === 2){
    // draw posture line (yellow)
    ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); ctx.lineTo(points[1].x, points[1].y); ctx.stroke();

    // choose lower point (C7) as baseline origin
    const lower = (points[0].y > points[1].y) ? points[0] : points[1];

    // draw horizontal baseline to the LEFT (clamped to 0)
    const baselineEnd = { x: 0, y: lower.y };
    ctx.strokeStyle = 'white'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(lower.x, lower.y); ctx.lineTo(baselineEnd.x, baselineEnd.y); ctx.stroke();

    // calculate angle between line (p1->p2) and horizontal
    const dx = points[1].x - points[0].x;
    const dy = points[1].y - points[0].y;
    let angle = Math.abs(Math.atan2(dy, dx) * (180/Math.PI));
    if(angle > 90) angle = 180 - angle;

    // angle label: left/up from lower point, keep inside canvas
    const labelX = Math.max(8, lower.x - 70);
    const labelY = Math.max(18, lower.y - 10);
    ctx.fillStyle = '#212121';
    ctx.font = 'bold 16px Segoe UI, Poppins, sans-serif';
    ctx.fillText(`${angle.toFixed(2)}°`, labelX, labelY);

    result.innerHTML = `Current attempt: CVA = <strong>${angle.toFixed(2)}°</strong> — click "Save Attempt" to record.`;
    saveAttemptBtn.style.display = 'inline-block';

    // store temporarily in currentAttempt to save later
    currentAttempt = { angle: parseFloat(angle.toFixed(2)), points: [ {...points[0]}, {...points[1]} ] };

    // prevent more than 2 points stacked for visualization
    // do not reset points here so user can re-click Reset Points if needed
  }
});

/* ============================
   Save attempt, history, averaging (original behaviors)
   ============================ */
saveAttemptBtn.addEventListener('click', ()=>{
  if(!currentAttempt) return;
  if(attemptCount >= maxAttempts){
    result.innerHTML = "<span class='warning'>⚠️ Maximum attempts reached.</span>";
    saveAttemptBtn.style.display = 'none';
    return;
  }
  savedAttempts.push(currentAttempt);
  attemptCount++;
  // draw saved attempt on canvas with attempt-specific color
  const idx = savedAttempts.length - 1;
  const c = attemptColors[idx % attemptColors.length];
  ctx.strokeStyle = c; ctx.fillStyle = c; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(currentAttempt.points[0].x,currentAttempt.points[0].y); ctx.lineTo(currentAttempt.points[1].x,currentAttempt.points[1].y); ctx.stroke();
  currentAttempt.points.forEach(p=>{
    ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
  });

  // append to history UI
  const card = document.createElement('div');
  card.className = 'historyCard';
  const avgSoFar = savedAttempts.reduce((a,b)=>a+b.angle,0)/savedAttempts.length;
  card.style.background = idx===0? '#fff8e1' : (idx===1? '#e8f5e9' : '#e3f2fd');
  card.innerHTML = `<b>Attempt ${idx+1}</b>: CVA = ${currentAttempt.angle}°<br><small>Saved</small>`;
  historyBox.prepend(card);

  // persist history in localStorage
  localStorage.setItem('posturaHistory', historyBox.innerHTML);
  // reset currentAttempt & UI
  currentAttempt = null;
  saveAttemptBtn.style.display = 'none';
  result.innerHTML = `Saved attempt ${idx+1}.`;
  // if reached max attempts, compute average
  if(attemptCount >= maxAttempts) displayAverage();
});

function displayAverage(){
  if(savedAttempts.length === 0) return;
  const sum = savedAttempts.reduce((a,b)=>a+b.angle,0);
  const avg = (sum/savedAttempts.length).toFixed(2);
  let label='', color='', recommendation='';
  if(avg >= 55){ label='Good posture'; color='green'; recommendation='Maintain your posture.'; }
  else if(avg >= 45){ label='At risk'; color='orange'; recommendation='Try to correct forward head posture.'; }
  else { label='Poor posture'; color='red'; recommendation='Consult a professional for posture correction.'; }
  result.innerHTML = `<b>Average CVA: ${avg}°</b><br><span style="color:${color}">${label}</span><br>${recommendation}`;
}

/* ============================
   Reset points & reset image (original)
   ============================ */
resetPointsBtn.addEventListener('click', ()=>{
  // redraw base image and saved attempts
  currentAttempt = null;
  points = [];
  drawCanvas();
  saveAttemptBtn.style.display = 'none';
  result.innerHTML = "Click 2 points: (1) Tragus, (2) C7";
});

resetImageBtn.addEventListener('click', ()=>{
  // if saved attempts exist, push history card (original behavior kept)
  if(savedAttempts.length > 0){
    const sum = savedAttempts.reduce((acc,obj)=>acc+obj.angle,0);
    const avgCVA = (sum/savedAttempts.length).toFixed(2);
    let label='', color='', rec='';
    if(avgCVA >= 55){ label='Good posture'; color='green'; rec='Maintain your posture.'; }
    else if(avgCVA >= 45){ label='At risk'; color='orange'; rec='Try to correct forward head posture.'; }
    else { label='Poor posture'; color='red'; rec='Consult a professional for posture correction.'; }

    const card = document.createElement('div');
    card.className = 'historyCard';
    card.style.background = color==='green'?'#e8f5e9':color==='orange'?'#fff3e0':'#ffebee';
    let cardHTML = `<b>Previous Image Attempts:</b><br>`;
    savedAttempts.forEach((obj,i)=>{ cardHTML += `Attempt ${i+1}: CVA = ${obj.angle}°<br>`; });
    cardHTML += `<hr><b>Average CVA:</b> ${avgCVA}°<br><b>Posture:</b> <span style="color:${color}">${label}</span><br><b>Recommendation:</b> ${rec}<br>`;
    card.innerHTML = cardHTML;
    historyBox.prepend(card);
    localStorage.setItem('posturaHistory', historyBox.innerHTML);
  }

  // clear canvas & reset variables
  ctx.clearRect(0,0,canvas.width,canvas.height);
  img = new Image();
  canvas.width = 0; canvas.height = 0;
  currentAttempt = null;
  savedAttempts = []; attemptCount = 0;
  segmentationMask = null;
  upload.value = '';
  saveAttemptBtn.style.display = 'none';
  result.innerHTML = "Upload or capture a new photo";
});

/* ============================
   History clearing & loading
   ============================ */
clearHistoryBtn.addEventListener('click', ()=>{ historyBox.innerHTML=''; localStorage.removeItem('posturaHistory'); });

function loadHistory(){
  const saved = localStorage.getItem('posturaHistory');
  if(saved) historyBox.innerHTML = saved;
}

/* ============================
   Page unload cleanup (stop camera)
   ============================ */
window.addEventListener('beforeunload', ()=>{
  if(stream) stream.getTracks().forEach(t => t.stop());
});
</script>
</body>
</html>

